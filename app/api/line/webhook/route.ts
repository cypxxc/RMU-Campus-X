/**
 * LINE Webhook API Route
 * ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥‡∏î‡πâ‡∏ß‡∏¢‡∏≠‡∏µ‡πÄ‡∏°‡∏• (‡πÉ‡∏ä‡πâ Firebase REST API)
 */

import { NextRequest, NextResponse } from "next/server"
import { verifySignature, sendReplyMessage } from "@/lib/line"

const FIREBASE_PROJECT = "resource-4e4fc"
const FIREBASE_API_KEY = "AIzaSyAhtR1jX2lycnS2xYLhiAtMAjn5dLOYAZM"

interface LineEvent {
  type: string
  replyToken: string
  source: {
    type: string
    userId: string
  }
  message?: {
    type: string
    text: string
  }
}

interface LineWebhookBody {
  events: LineEvent[]
}

// Firebase REST API helper
async function firestoreQuery(collectionPath: string, field: string, value: string) {
  const url = `https://firestore.googleapis.com/v1/projects/${FIREBASE_PROJECT}/databases/(default)/documents:runQuery?key=${FIREBASE_API_KEY}`
  
  const body = {
    structuredQuery: {
      from: [{ collectionId: collectionPath }],
      where: {
        fieldFilter: {
          field: { fieldPath: field },
          op: "EQUAL",
          value: { stringValue: value }
        }
      },
      limit: 1
    }
  }

  const response = await fetch(url, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body)
  })

  const data = await response.json()
  
  if (!response.ok) {
    throw new Error(`Firestore query failed: ${response.status} - ${JSON.stringify(data)}`)
  }

  return data
}

async function firestoreUpdate(documentPath: string, fields: Record<string, unknown>) {
  // Build updateMask with separate parameter for each field
  const fieldMask = Object.keys(fields).map(f => `updateMask.fieldPaths=${f}`).join('&')
  const url = `https://firestore.googleapis.com/v1/projects/${FIREBASE_PROJECT}/databases/(default)/documents/${documentPath}?key=${FIREBASE_API_KEY}&${fieldMask}`
  
  // Convert fields to Firestore format
  const firestoreFields: Record<string, unknown> = {}
  for (const [key, value] of Object.entries(fields)) {
    if (typeof value === "string") {
      firestoreFields[key] = { stringValue: value }
    } else if (typeof value === "boolean") {
      firestoreFields[key] = { booleanValue: value }
    } else if (value === null) {
      firestoreFields[key] = { nullValue: null }
    } else if (typeof value === "object") {
      // For nested objects like lineNotifications
      const mapFields: Record<string, unknown> = {}
      for (const [k, v] of Object.entries(value as Record<string, unknown>)) {
        if (typeof v === "boolean") {
          mapFields[k] = { booleanValue: v }
        }
      }
      firestoreFields[key] = { mapValue: { fields: mapFields } }
    }
  }

  console.log("[LINE Webhook] Updating:", documentPath, "with fields:", Object.keys(fields))

  const response = await fetch(url, {
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ fields: firestoreFields })
  })

  const data = await response.json()
  
  if (!response.ok) {
    console.error("[LINE Webhook] Update failed:", data)
    throw new Error(`Firestore update failed: ${response.status} - ${JSON.stringify(data)}`)
  }

  console.log("[LINE Webhook] Update success!")
  return data
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.text()
    const signature = request.headers.get("x-line-signature")

    if (!signature) {
      return NextResponse.json({ error: "Missing signature" }, { status: 401 })
    }

    const isValid = await verifySignature(body, signature)
    if (!isValid) {
      return NextResponse.json({ error: "Invalid signature" }, { status: 401 })
    }

    const data: LineWebhookBody = JSON.parse(body)

    for (const event of data.events) {
      if (event.type === "follow") {
        await sendReplyMessage(event.replyToken, [
          {
            type: "text",
            text: `‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ! üëã ‡∏¢‡∏¥‡∏ô‡∏î‡∏µ‡∏ï‡πâ‡∏≠‡∏ô‡∏£‡∏±‡∏ö‡∏™‡∏π‡πà RMU Exchange Notification

üìß ‡∏û‡∏¥‡∏°‡∏û‡πå‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ö‡∏±‡∏ç‡∏ä‡∏µ
(‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á: student@rmu.ac.th)`,
          },
        ])
      } else if (event.type === "message" && event.message?.type === "text") {
        await handleTextMessage(event)
      }
    }

    return NextResponse.json({ success: true })
  } catch (error) {
    console.error("[LINE Webhook] Error:", error)
    return NextResponse.json({ error: String(error) }, { status: 500 })
  }
}

async function handleTextMessage(event: LineEvent) {
  const text = event.message?.text?.trim() || ""
  const lineUserId = event.source.userId

  try {
    // Check if text looks like an email
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
    if (emailRegex.test(text)) {
      // Find user by email
      let result
      try {
        result = await firestoreQuery("users", "email", text)
      } catch (queryError) {
        // Show the actual error to user for debugging
        await sendReplyMessage(event.replyToken, [
          { type: "text", text: `‚ùå Query Error: ${String(queryError)}` },
        ])
        return
      }
      
      // Check if user found
      if (!result || result.length === 0 || !result[0].document) {
        await sendReplyMessage(event.replyToken, [
          {
            type: "text",
            text: `‚ùå ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏≠‡∏µ‡πÄ‡∏°‡∏• "${text}"

‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡πÉ‡∏´‡πâ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á ‡∏´‡∏£‡∏∑‡∏≠‡∏•‡∏á‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô‡∏ö‡∏ô‡πÄ‡∏ß‡πá‡∏ö‡∏Å‡πà‡∏≠‡∏ô`,
          },
        ])
        return
      }

      const doc = result[0].document
      const docPath = doc.name.split("/documents/")[1] // Get path like "users/xxx"
      
      // Link the account
      try {
        await firestoreUpdate(docPath, {
          lineUserId: lineUserId,
          lineNotifications: {
            enabled: true,
            exchangeRequest: true,
            exchangeStatus: true,
            exchangeComplete: true,
          },
        })
      } catch (updateError) {
        await sendReplyMessage(event.replyToken, [
          { type: "text", text: `‚ùå Update Error: ${String(updateError)}` },
        ])
        return
      }

      await sendReplyMessage(event.replyToken, [
        {
          type: "text",
          text: `‚úÖ ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!

üìß ${text}

‡∏Ñ‡∏∏‡∏ì‡∏à‡∏∞‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏ú‡πà‡∏≤‡∏ô LINE ‡πÅ‡∏•‡πâ‡∏ß üéâ`,
        },
      ])
      return
    }

    // Check status
    if (text === "‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞" || text === "status") {
      try {
        const result = await firestoreQuery("users", "lineUserId", lineUserId)
        
        if (!result || result.length === 0 || !result[0].document) {
          await sendReplyMessage(event.replyToken, [
            { type: "text", text: "‚ùå ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ö‡∏±‡∏ç‡∏ä‡∏µ\n\nüìß ‡∏û‡∏¥‡∏°‡∏û‡πå‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ö‡∏±‡∏ç‡∏ä‡∏µ" },
          ])
        } else {
          const fields = result[0].document.fields
          const email = fields?.email?.stringValue || "‡πÑ‡∏°‡πà‡∏£‡∏∞‡∏ö‡∏∏"
          await sendReplyMessage(event.replyToken, [
            { type: "text", text: `‚úÖ ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡πÅ‡∏•‡πâ‡∏ß\n\nüìß ${email}` },
          ])
        }
      } catch (statusError) {
        await sendReplyMessage(event.replyToken, [
          { type: "text", text: `‚ùå Status Error: ${String(statusError)}` },
        ])
      }
      return
    }

    // Unlink account
    if (text === "‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å" || text === "unlink" || text === "‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠") {
      try {
        const result = await firestoreQuery("users", "lineUserId", lineUserId)
        
        if (!result || result.length === 0 || !result[0].document) {
          await sendReplyMessage(event.replyToken, [
            { type: "text", text: "‚ùå ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏ó‡∏µ‡πà‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏Å‡∏±‡∏ö LINE ‡∏ô‡∏µ‡πâ" },
          ])
        } else {
          const doc = result[0].document
          const docPath = doc.name.split("/documents/")[1]
          
          // Remove LINE connection
          await firestoreUpdate(docPath, {
            lineUserId: null,
            lineNotifications: {
              enabled: false,
              exchangeRequest: false,
              exchangeStatus: false,
              exchangeComplete: false,
            },
          })
          
          const email = doc.fields?.email?.stringValue || "‡∏ö‡∏±‡∏ç‡∏ä‡∏µ"
          await sendReplyMessage(event.replyToken, [
            { 
              type: "text", 
              text: `‚úÖ ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!

üìß ${email}

‡∏Ñ‡∏∏‡∏ì‡∏à‡∏∞‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏ú‡πà‡∏≤‡∏ô LINE ‡∏≠‡∏µ‡∏Å‡∏ï‡πà‡∏≠‡πÑ‡∏õ

üí° ‡∏´‡∏≤‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡πÉ‡∏´‡∏°‡πà ‡∏û‡∏¥‡∏°‡∏û‡πå‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì` 
            },
          ])
        }
      } catch (unlinkError) {
        await sendReplyMessage(event.replyToken, [
          { type: "text", text: `‚ùå Unlink Error: ${String(unlinkError)}` },
        ])
      }
      return
    }

    // Default help
    await sendReplyMessage(event.replyToken, [
      {
        type: "text",
        text: `üìã ‡∏ß‡∏¥‡∏ò‡∏µ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô:

üìß ‡∏û‡∏¥‡∏°‡∏û‡πå‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ö‡∏±‡∏ç‡∏ä‡∏µ
‚Ä¢ "‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞" - ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞
‚Ä¢ "‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å" - ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠`,
      },
    ])
  } catch (error) {
    console.error("[LINE Webhook] handleTextMessage error:", error)
    await sendReplyMessage(event.replyToken, [
      { type: "text", text: `‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ${String(error)}` },
    ])
  }
}
