rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // ============================================================================
    // ðŸ›¡ï¸ SECURITY UTILITIES
    // ============================================================================

    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    // Admin: by existence of admins/{uid} (manually created)
    function isAdmin() {
      return isAuthenticated()
        && exists(/databases/$(database)/documents/admins/$(request.auth.uid));
    }

    function hasRMUEmail() {
      return isAuthenticated()
        && request.auth.token.email != null
        && request.auth.token.email.matches('^[0-9]{12}@rmu\\.ac\\.th$');
    }

    function isVerifiedEmail() {
      return isAuthenticated() && request.auth.token.email_verified == true;
    }

    // âœ… FIX: use exists() before get().data; default status to ACTIVE if missing
    function isActiveUser() {
      let p = /databases/$(database)/documents/users/$(request.auth.uid);
      return exists(p)
        && (get(p).data.get('status', 'ACTIVE') in ['ACTIVE', 'WARNING']);
    }

    function isEligibleStudent() {
      return isAuthenticated()
        && isVerifiedEmail()
        && hasRMUEmail()
        && isActiveUser();
    }

    function canUseApp() {
      return isAdmin() || isEligibleStudent();
    }

    function notUpdating(fields) {
      return !request.resource.data.diff(resource.data).affectedKeys().hasAny(fields);
    }

    function onlyUpdating(fields) {
      return request.resource.data.diff(resource.data).affectedKeys().hasOnly(fields);
    }

    // ============================================================================
    // ðŸ‘¤ USERS
    // ============================================================================
    match /users/{userId} {

      function isValidUserData(data) {
        let displayName = data.get('displayName', null);
        let photoURL = data.get('photoURL', null);
        let bio = data.get('bio', null);

        return (displayName == null ||
                (displayName is string && displayName.size() >= 1 && displayName.size() <= 50))
            && (photoURL == null ||
                (photoURL is string && photoURL.size() < 2000))
            && (bio == null ||
                (bio is string && bio.size() <= 300));
      }

      // âœ… Student-only system: allow only eligible students/admin to read
      // - get: any eligible student/admin; OR own doc for RMU+verified (so new users can check profile exists before create)
      // - list: admin only (prevent directory scrape)
      allow get: if canUseApp()
        || (isOwner(userId) && hasRMUEmail() && isVerifiedEmail());
      allow list: if isAdmin();

      allow create: if isOwner(userId)
        && hasRMUEmail()
        && !exists(/databases/$(database)/documents/users/$(userId))
        && request.resource.data.email == request.auth.token.email
        && request.resource.data.get('isAdmin', false) == false
        && request.resource.data.get('status', 'ACTIVE') == 'ACTIVE'
        && request.resource.data.get('warningCount', 0) == 0
        && isValidUserData(request.resource.data);

      allow update: if (isOwner(userId) && canUseApp()
        && notUpdating([
          'email', 'uid', 'isAdmin', 'status', 'warningCount',
          'createdAt', 'bannedReason', 'suspendedUntil'
        ])
        && isValidUserData(request.resource.data))
        || isAdmin();

      allow delete: if isAdmin();
    }

    // ============================================================================
    // ðŸ“¦ ITEMS
    // ============================================================================
    match /items/{itemId} {

      function isValidItemData(data) {
        let location = data.get('location', null);
        let imageUrls = data.get('imageUrls', null);

        return data.title is string && data.title.size() >= 1 && data.title.size() <= 100
            && data.description is string && data.description.size() <= 2000
            && data.category in ['electronics', 'books', 'furniture', 'clothing', 'sports', 'other']
            && data.status in ['available', 'pending', 'completed']
            && (location == null || (location is string && location.size() <= 100))
            && (imageUrls == null || (imageUrls is list && imageUrls.size() <= 5));
      }

      // âœ… student-only browsing
      allow get, list: if canUseApp();

      // postedAt: allow serverTimestamp() (sentinel != request.time in rules)
      allow create: if canUseApp()
        && request.resource.data.postedBy == request.auth.uid
        && request.resource.data.postedByEmail == request.auth.token.email
        && request.resource.data.status == 'available'
        && request.resource.data.keys().hasAll(['postedAt'])
        && isValidItemData(request.resource.data);

      // âœ… FIX: remove "any active user can update status"
      allow update: if (
          // owner edits (cannot change poster fields)
          (canUseApp()
            && resource.data.postedBy == request.auth.uid
            && notUpdating(['postedBy', 'postedByEmail', 'postedAt'])
            && isValidItemData(request.resource.data)
          )
          || isAdmin()
        );

      allow delete: if (canUseApp() && resource.data.postedBy == request.auth.uid)
        || isAdmin();
    }

    // ============================================================================
    // ðŸ¤ EXCHANGES
    // ============================================================================
    match /exchanges/{exchangeId} {

      function isParticipantExistingDoc() {
        return resource.data.requesterId == request.auth.uid
          || resource.data.ownerId == request.auth.uid;
      }

      function isValidStatusTransition(oldStatus, newStatus) {
        return (oldStatus == 'pending' && newStatus in ['accepted', 'rejected', 'cancelled'])
            || (oldStatus == 'accepted' && newStatus in ['in_progress', 'cancelled'])
            || (oldStatus == 'in_progress' && newStatus in ['completed', 'cancelled'])
            || (oldStatus == newStatus); // allow no-op
      }

      // âœ… get: participants or admin; list: any canUseApp (query filtered by requesterId/ownerId)
      allow get: if canUseApp() && (isParticipantExistingDoc() || isAdmin());
      allow list: if canUseApp();

      // createdAt: allow serverTimestamp() (sentinel != request.time in rules)
      allow create: if canUseApp()
        && request.resource.data.requesterId == request.auth.uid
        && request.resource.data.requesterEmail == request.auth.token.email
        && request.resource.data.status == 'pending'
        && request.resource.data.keys().hasAll(['createdAt']);

      allow update: if (
          (canUseApp()
            && isParticipantExistingDoc()
            && notUpdating([
              'requesterId', 'requesterEmail',
              'ownerId', 'ownerEmail',
              'itemId', 'itemTitle',
              'createdAt'
            ])
            && isValidStatusTransition(resource.data.status, request.resource.data.status)
          )
          || isAdmin()
        );

      allow delete: if isAdmin();
    }

    // ============================================================================
    // ðŸ’¬ CHAT MESSAGES
    // ============================================================================
    match /chatMessages/{messageId} {

      function isMessageParticipant() {
        let exPath = /databases/$(database)/documents/exchanges/$(resource.data.exchangeId);
        return exists(exPath) && (
          get(exPath).data.requesterId == request.auth.uid
          || get(exPath).data.ownerId == request.auth.uid
        );
      }

      function canSendMessage() {
        let exPath = /databases/$(database)/documents/exchanges/$(request.resource.data.exchangeId);
        return exists(exPath) && (
          get(exPath).data.requesterId == request.auth.uid
          || get(exPath).data.ownerId == request.auth.uid
        );
      }

      // à¸œà¸¹à¹‰à¸£à¸±à¸šà¸­à¸±à¸›à¹€à¸”à¸•à¹€à¸‰à¸žà¸²à¸° readAt à¹„à¸”à¹‰; à¸œà¸¹à¹‰à¸ªà¹ˆà¸‡à¸­à¸±à¸›à¹€à¸”à¸•à¹€à¸‰à¸žà¸²à¸° message, updatedAt, imageUrl, imageType à¹„à¸”à¹‰
      function allowedMessageUpdateKeys() {
        let keys = request.resource.data.diff(resource.data).affectedKeys();
        return (request.auth.uid != resource.data.senderId && keys.hasOnly(['readAt']))
          || (request.auth.uid == resource.data.senderId && keys.hasOnly(['message', 'updatedAt', 'imageUrl', 'imageType']));
      }

      allow get, list: if canUseApp() && (isMessageParticipant() || isAdmin());

      allow create: if canUseApp()
        && request.resource.data.senderId == request.auth.uid
        && request.resource.data.senderEmail == request.auth.token.email
        && request.resource.data.keys().hasAll(['createdAt'])
        && canSendMessage();

      allow update: if canUseApp() && isMessageParticipant() && allowedMessageUpdateKeys();
      allow delete: if isAdmin() || (canUseApp() && resource.data.senderId == request.auth.uid);
    }

    // à¸à¸³à¸¥à¸±à¸‡à¸žà¸´à¸¡à¸žà¹Œ (typing indicator) à¸•à¹ˆà¸­ exchange
    match /chatTyping/{exchangeId} {
      function isExchangeParticipant() {
        let ex = get(/databases/$(database)/documents/exchanges/$(exchangeId));
        return ex.data.ownerId == request.auth.uid || ex.data.requesterId == request.auth.uid;
      }
      allow get, create, update: if canUseApp() && isExchangeParticipant();
      allow delete: if canUseApp() && isExchangeParticipant();
    }

    // ============================================================================
    // ðŸŽ« REPORTS
    // ============================================================================
    match /reports/{reportId} {
      allow get: if canUseApp() && (resource.data.reporterId == request.auth.uid || isAdmin());
      allow list: if canUseApp(); // user can query own reports (where reporterId == auth.uid)

      // createdAt: allow serverTimestamp() (sentinel != request.time in rules)
      allow create: if canUseApp()
        && request.resource.data.reporterId == request.auth.uid
        && request.resource.data.reporterEmail == request.auth.token.email
        && request.resource.data.status == 'new'
        && request.resource.data.keys().hasAll(['createdAt'])
        && request.resource.data.reportType in ['item_report', 'exchange_report', 'user_report'];

      allow update, delete: if isAdmin();
    }

    // ============================================================================
    // ðŸŽ« SUPPORT TICKETS
    // ============================================================================
    match /support_tickets/{ticketId} {
      allow get: if canUseApp() && (resource.data.userId == request.auth.uid || isAdmin());
      allow list: if canUseApp(); // user can query own tickets (where userId == auth.uid)

      allow create: if canUseApp()
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.userEmail == request.auth.token.email
        && request.resource.data.status == 'new';

      allow update: if isAdmin()
        || (canUseApp()
          && resource.data.userId == request.auth.uid
          && notUpdating([
            'status', 'priority', 'repliedBy', 'repliedByEmail',
            'repliedAt', 'adminReply', 'resolvedAt', 'userId', 'userEmail'
          ])
        );

      allow delete: if isAdmin();
    }

    // ============================================================================
    // ðŸ”” NOTIFICATIONS
    // ============================================================================
    match /notifications/{notificationId} {
      allow get: if canUseApp() && resource.data.userId == request.auth.uid;
      allow list: if canUseApp(); // user can query own notifications (where userId == auth.uid)

      allow create: if canUseApp()
        && request.resource.data.userId == request.auth.uid;

      allow update: if canUseApp()
        && resource.data.userId == request.auth.uid
        && onlyUpdating(['isRead']);

      allow delete: if canUseApp() && resource.data.userId == request.auth.uid;
    }

    // ============================================================================
    // â­ REVIEWS
    // ============================================================================
    match /reviews/{reviewId} {
      // student-only read (à¸–à¹‰à¸²à¸•à¹‰à¸­à¸‡à¸à¸²à¸£ public à¸ˆà¸£à¸´à¸‡à¸„à¹ˆà¸­à¸¢à¹€à¸›à¸¥à¸µà¹ˆà¸¢à¸™)
      allow get, list: if canUseApp();

      // createdAt: allow serverTimestamp() (sentinel != request.time in rules)
      allow create: if canUseApp()
        && request.resource.data.reviewerId == request.auth.uid
        && request.resource.data.keys().hasAll(['createdAt']);

      allow update: if false;
      allow delete: if isAdmin();
    }

    // ============================================================================
    // â¤ï¸ FAVORITES
    // ============================================================================
    match /favorites/{favoriteId} {
      // âœ… FIX: no split(); rely on stored userId
      allow get, list: if canUseApp() && resource.data.userId == request.auth.uid;

      allow create: if canUseApp()
        && request.resource.data.userId == request.auth.uid;

      allow delete: if canUseApp() && resource.data.userId == request.auth.uid;
      allow update: if false;
    }

    // ============================================================================
    // ðŸ“ DRAFTS
    // ============================================================================
    match /drafts/{draftId} {
      allow create: if canUseApp()
        && request.resource.data.userId == request.auth.uid;

      allow get, update, delete: if canUseApp()
        && resource.data.userId == request.auth.uid;

      allow list: if canUseApp(); // user can query own drafts (where userId == auth.uid)
    }

    // ============================================================================
    // ðŸ‘® ADMIN & SYSTEM
    // ============================================================================
    match /admins/{userId} {
      allow get: if isOwner(userId) || isAdmin();
      allow list: if isAdmin();
      allow write: if false;
    }

    match /adminLogs/{logId} {
      allow get, list: if isAdmin();
      allow write: if false;
    }

    match /userWarnings/{warningId} {
      allow get: if canUseApp() && (resource.data.userId == request.auth.uid || isAdmin());
      allow list: if canUseApp(); // user can query own warnings (where userId == auth.uid)
      allow write: if false;
    }

    match /cases/{caseId} {
      allow get, list, create, update, delete: if isAdmin();
    }

    // Server-only: LINE webhook/link (Admin SDK)
    match /pendingLineLinks/{id} {
      allow read, write: if false;
    }
    match /lineChatSessions/{lineUserId} {
      allow read, write: if false;
    }

    // ============================================================================
    // ðŸš« DEFAULT DENY
    // ============================================================================
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
